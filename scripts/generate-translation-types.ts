#!/usr/bin/env tsx

import * as fs from 'fs';
import * as path from 'path';

interface TranslationObject {
  [key: string]: string | TranslationObject;
}

function flattenKeys(obj: TranslationObject, prefix = ''): string[] {
  const keys: string[] = [];
  
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    
    if (typeof value === 'string') {
      keys.push(fullKey);
    } else if (typeof value === 'object' && value !== null) {
      keys.push(...flattenKeys(value, fullKey));
    }
  }
  
  return keys;
}

function generateTranslationTypes() {
  const localesDir = path.join(process.cwd(), 'public', 'locales', 'en');
  const outputFile = path.join(process.cwd(), 'src', 'types', 'translations.ts');
  
  // Ensure output directory exists
  const outputDir = path.dirname(outputFile);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  let allKeys: string[] = [];
  
  // Read all JSON files in the English locale directory
  const files = fs.readdirSync(localesDir).filter(file => file.endsWith('.json'));
  
  for (const file of files) {
    const filePath = path.join(localesDir, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    
    try {
      const translations: TranslationObject = JSON.parse(content);
      const namespace = path.basename(file, '.json');
      const keys = flattenKeys(translations);
      
      // Add namespace prefix to keys
      const namespacedKeys = keys.map(key => `${namespace}.${key}`);
      allKeys.push(...namespacedKeys);
    } catch (error) {
      console.error(`Error parsing ${file}:`, error);
    }
  }
  
  // Generate TypeScript type definition
  const typeDefinition = `// Auto-generated translation keys
// Do not edit this file manually - it will be overwritten

export type TranslationKey = 
${allKeys.map(key => `  | '${key}'`).join('\n')};

export type TranslationNamespace = ${files.map(file => `'${path.basename(file, '.json')}'`).join(' | ')};

// Helper type for nested translation objects
export interface TranslationValues {
  [key: string]: string | number | boolean | Date | null | undefined;
}
`;
  
  fs.writeFileSync(outputFile, typeDefinition);
  console.log(`âœ… Generated translation types with ${allKeys.length} keys`);
  console.log(`ğŸ“ Output: ${outputFile}`);
}

if (require.main === module) {
  generateTranslationTypes();
}

export { generateTranslationTypes }; 